import{b as K,t as Z}from"../chunks/disclose-version.BcvwuTr4.js";import{u as $,w as ee,z as x,A as te,B as ae}from"../chunks/runtime.Cjuk95Ml.js";import{s as F}from"../chunks/attributes.Bt4tGm2O.js";import{b as ne}from"../chunks/this.DsiEjiIA.js";import{o as oe}from"../chunks/index-client.DibeTDnh.js";import{C as re,i as se,A as ie,R as ce,T as ue,d as le,a as me,v as H,S as N,O as de}from"../chunks/Scene.D-IVrs4_.js";import{R as he,a as pe,b as fe,c as ge,Q as we}from"../chunks/miscControls.svelte.CK7hsPxu.js";import{g as j}from"../chunks/globalState.svelte.CHPqU7Zl.js";import{a as xe,b as ve,l as W,p as Ce,c as be}from"../chunks/cameraControls.DDVdYK0m.js";import{S as ye}from"../chunks/SceneObject.Dp-QgdB2.js";import{g as q}from"../chunks/controls.svelte.EJqBkrRw.js";import{g as Me}from"../chunks/entry.DT83CXea.js";function Se(p){const f=q();let a="Subsurface scattering";const n=f.addControl({name:"Enable",group:a,type:"checkbox",value:!0});n.onChange(o=>p.updateBufferValues({subsurfaceScattering:o?1:0}));const y=f.addControl({name:"Subsurface depth",group:a,type:"range",value:4,step:.1,min:0,max:50});y.onChange(o=>p.updateBufferValues({subsurfaceDepth:o})),a="Transparency";const u=f.addControl({name:"Enable",group:a,type:"checkbox",value:!0});u.onChange(o=>p.updateBufferValues({transparency:o?1:0}));const l=f.addControl({name:"Maximum transparency depth",group:a,type:"range",value:.2,min:0,max:1,step:.01});l.onChange(o=>p.updateBufferValues({maximumTransparencyDepth:o})),a="Reflection";const T=f.addControl({name:"Enable",group:a,type:"checkbox",value:!0});T.onChange(o=>p.updateBufferValues({reflections:o?1:0}));const v=f.addControl({name:"Reflection factor",group:a,type:"range",value:.05,min:0,max:1,step:.01});return v.onChange(o=>p.updateBufferValues({reflectionFactor:o})),{subsurfaceScattering:n,subsurfaceDepth:y,transparency:u,maximumTransparencyDepth:l,reflections:T,reflectionFactor:v}}var Te=Z('<canvas class="h-full w-full"></canvas>');function Ae(p,f){$(f,!0),navigator.gpu||(alert("Your browser doesn't support WebGPU. Please use Chrome/Edge 113 or newer."),Me("/"));let a=te(void 0);const n=new re;j.camera=n;const y=q(),u=new he({clearColor:"white",fragmentColor:"blue",cameraPosition:n.position,projectionMatrixInverse:n.projectionMatrixInverse,viewMatrixInverse:n.viewMatrixInverse,numberOfSteps:500,minimumHitDistance:.4,maximumTraceDistance:1e3,subsurfaceDepth:4,maximumTransparencyDepth:.2,reflectionFactor:.05,subsurfaceScattering:1,transparency:1,reflections:1,molecularStructure:1,near:n.near,far:n.far}),l=xe(u),T=Se(u);pe(u),ve(n,u),fe();const v=y.addControl({name:"Grid size",type:"number",value:256,max:1024}),o=y.addControl({name:"Radius",type:"number",value:5});let I;oe(async()=>{if(!x(a))return;const C=x(a).getContext("webgpu");if(!C)return;const{device:i}=await se({deviceOptions:t=>({requiredLimits:{maxBufferSize:t.limits.maxBufferSize}})}),z=new ie({eventSource:x(a),camera:n,distance:80});j.contols=z;const g=new ce({context:C,device:i,clearColor:"white"}),R=await W(l.molecule.value);if(!R)return;I=R;const V=new ue({format:"bgra8unorm",size:[x(a).width,x(a).height],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});let b=await B();l.molecule.onChange(async()=>{const t=await W(l.molecule.value);t&&(I=t,b=await B())}),v.onChange(async t=>{const e=Math.min(1024,i.limits.maxTextureDimension3D);t>e?v.value=e:b=await B()}),o.onChange(async()=>{b=await B()}),le(t=>{j.fps=1e3/t,z.update(t),u.update(i,{cameraPosition:n.position,projectionMatrixInverse:n.projectionMatrixInverse,viewMatrixInverse:n.viewMatrixInverse}),l.showMoleculeStructure.value&&T.transparency.value&&g.render(b.molecules,{view:l.showMoleculeSurface.value?V.createView(i):void 0,camera:n}),l.showMoleculeSurface.value&&g.render(b.rayMarching,{camera:n,depth:!1})}),me({canvas:x(a),device:i,onResize:async t=>{n.aspect=t.clientWidth/t.clientHeight,g.onCanvasResized(t.width,t.height);const{width:e,height:r}=t;V.updateSize({width:e,height:r}),await b.rayMarching.load(i)}});async function B(){const t=Ce(I),{scene:e,scale:r}=await Q(t.atoms);for(const c of t.atoms){const[h,S,s]=c.position;c.position=H.create(h*r,S*r,s*r)}const{atoms:w,bonds:M}=be(t,r*.1),m=[...w,M];return{molecules:await L(l.showMoleculeStructure.value?m:[]),rayMarching:e}}async function L(t){const e=new N(t);return await e.load(i),g.load(e),e}async function Q(t){let e={width:{min:0,max:0},height:{min:0,max:0},depth:{min:0,max:0}};const r=o.value,w=1;for(const _ of t){const[P,E,G]=_.position;e.width.min=Math.min(e.width.min,P-r-w),e.width.max=Math.max(e.width.max,P+r+w),e.height.min=Math.min(e.height.min,E-r-w),e.height.max=Math.max(e.height.max,E+r+w),e.depth.min=Math.min(e.depth.min,G-r-w),e.depth.max=Math.max(e.depth.max,G+r+w)}const M=1;let m=(e.width.max-e.width.min)*M,d=(e.height.max-e.height.min)*M,c=(e.depth.max-e.depth.min)*M;const h=v.value;let S=.001;Math.max(m,d,c)>h&&(S=-.001);let s=1;for(;;)if(s+=S,S>0){if(m*s>h||d*s>h||c*s>h){s-=.1;break}}else if(m*s<h&&d*s<h&&c*s<h)break;m*=s,d*=s,c*=s;const A=[];for(const _ of t){const[P,E,G]=_.position,k=new de;k.setPosition(H.create(U(P,e.width.min,e.width.max,0,m),U(E,e.height.min,e.height.max,0,d),U(G,e.depth.min,e.depth.max,0,c))),A.push(k)}console.time("Compute SDF Texture");const Y=await ge({device:i,width:m,height:d,depth:c,radius:r,scale:1,atoms:A});console.timeEnd("Compute SDF Texture"),u.updateBufferValues({width:m,height:d,depth:c});const X=new we,J=new ye(X,u,[Y,g.depthTexture,V]),O=new N(J,{depth:!1});return await O.load(i),{scene:O,width:m,height:d,depth:c,scale:s}}});function U(C,i,z,g,R){return(R-g)*((C-i)/(z-i))+g}var D=Te();F(D,"width",window.innerWidth),F(D,"height",window.innerHeight),ne(D,C=>ae(a,C),()=>x(a)),K(p,D),ee()}export{Ae as component};
